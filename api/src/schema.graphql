scalar JSON
scalar idList

enum Role {
    dev
    admin
    pm
}

type Token {
    token: String!
    ttl: Int!
}

type UserStory {
    id: ID!
    storyText: String!
    issueNumber: Int!
    tickets: [Ticket] @relation(name: "SUB_TASK", direction: IN)
    project: Project @relation(name: "USER_STORY", direction: OUT)
}

type User {
    id: ID!
    firstName: String!
    lastName: String!
    fullName: String
    username: String!
    email: String!
    password: String! @hasRole(roles:[admin])
    projects: [Member]
    userStories: [UserStory] @relation(name: "ASSIGNED_TASK", direction: OUT)
    tickets: [Ticket] @relation(name: "ASSIGNED_TASK", direction: OUT)
    created: [Created]
    avatar: String
    role: Role!
    comments: [Comment]
    commits: [Commit]
}

type Created @relation(name: "CREATED") {
    from: User
    to: Ticket
    timestamp: String!
}
type Comment @relation(name: "COMMENT") {
    from: User
    to: Ticket
    id: ID!
    timestamp: Int!
    message: String!
}
type Commit @relation(name: "COMMIT") {
    from: User
    to: Ticket
    id: ID!
    timestamp: Int!
    message: String!
    prevHourEstimate: Int!
    newHourEstimate: Int!
}
type Member @relation(name: "TEAM_MEMBER") {
    from: User
    to: Project
    role: Role!
}

type Project {
    id: ID!
    title: String!
    desc: String
    label: String!
    startDate: String!
    endDate: String!
    members: [Member]
    userStories: [UserStory] @relation(name: "USER_STORY", direction: IN)
    tickets: [Ticket] @relation(name: "TICKET", direction: IN)
    sprints: [Sprint] @relation(name: "SPRINT", direction: IN)
}

type Ticket {
    id: ID!
    issueNumber: Int
    hourEstimate: Int
    sprintPos: Int!
    userStory: UserStory @relation(name: "SUB_TASK", direction: OUT)
    title: String!
    desc: String
    done: Boolean
    sprint: Sprint @relation(name: "SPRINT_TASK", direction: OUT)
    project: Project @relation(name: "TICKET", direction: OUT)
    assignee: User @relation(name: "ASSIGNED_TASK", direction: IN)
    creator: Created
    comments: [Comment]
    commits: [Commit]
}

type Sprint {
    id: ID!
    sprintNo: Int!
    active: Boolean!
    startDate: String!
    endDate: String!
    tickets: [Ticket] @relation(name: "SPRINT_TASK", direction: IN)
    project: Project @relation(name: "SPRINT", direction: OUT)
}

type Query {
    getCurrentUser: User
    @cypher(statement: """
    MATCH (u:User {id: $cypherParams.currentUser.id})
    RETURN u
    """)

#    UserStory: [UserStory] @hasScope(scopes:["UserStory:Read"])
#    Project: [Project] @hasScope(scopes:["Project:Read"])
#    Ticket: [Ticket] @hasScope(scopes:["Ticket:Read"])
#    Sprint: [Sprint] @hasScope(scopes:["Sprint:Read"])
#    User: [User] @hasScope(scopes:["User:Read"])
    UserStory: [UserStory]
    Project: [Project]
    Ticket: [Ticket]
    Sprint: [Sprint]
    User: [User]
}
input _CommitInput {
    message: String!
    newEst: Int!
    timestamp: Int!
}
type Subscription {
    update(proId:String!): String
}

type Mutation {
    UpdateTicketAssignee(tick: _TicketInput!, remUser: _UserInput, addUser: _UserInput, project: _ProjectInput!): User
    UnassignedTicketSwitch(project: _ProjectInput!, tick: _TicketInput!, uStoryRemove: _UserStoryInput, sprintRemove: _SprintInput,uStoryAdd: _UserStoryInput,sprintAdd: _SprintInput ): String
    UStoryTicketSwitch(project: _ProjectInput!, tick: _TicketInput!, uStoryRemove: _UserStoryInput, sprintRemove: _SprintInput,uStoryAdd: _UserStoryInput,sprintAdd: _SprintInput ): String

    UpdateTicket(id: ID!, issueNumber: Int, hourEstimate: Int, sprintPos: Int, title: String, desc: String, done: Boolean):Ticket
#    @hasScope(scopes:["Ticket:Edit"])

    AddTicketComments(ticket: _TicketInput!, message: String!, project: _ProjectInput!): Ticket
#    @hasScope(scopes:["Ticket:Comment"])
    @cypher(statement:"""
    MATCH (t:Ticket),(u:User)
    WHERE t.id = $ticket.id AND u.id = $cypherParams.currentUser.id
    CREATE (u)-[com:COMMENT]->(t)
    SET com.id = apoc.create.uuid()
    SET com.timestamp = datetime().epochSeconds
    SET com.message = $message
    WITH t
    RETURN t
    """)
    AddTicketCommits(ticket: _TicketInput!, commit: _CommitInput!, project: _ProjectInput!): Ticket
    #    @hasScope(scopes:["Ticket:Comment"])
    @cypher(statement:"""
    MATCH (t:Ticket),(u:User)
    WHERE t.id = $ticket.id AND u.id = $cypherParams.currentUser.id
    CREATE (u)-[com:COMMIT]->(t)
    SET com.id = apoc.create.uuid()
    SET com.timestamp = datetime().epochSeconds
    SET com.message = $commit.message
    SET com.prevHourEstimate = t.hourEstimate
    SET com.newHourEstimate = $commit.newEst
    SET t.hourEstimate = $commit.newEst
    RETURN t
    """)

    DeleteTicket(ticket: _TicketInput!, project: _ProjectInput!): Ticket
#    @hasScope(scopes:["Ticket:Delete"])
    @cypher(statement:"""
    MATCH(t:Ticket {id: $ticket.id})
    WITH t, properties(t) AS tick
    DETACH DELETE t
    RETURN tick
    """)

    loginUser(username: String!, password: String!): JSON
    @cypher(statement:"""
    MATCH(u:User{username: $username})
    CREATE (u)-[rel:JWT]->(t: Token {token: $refTokenString})
    WITH t
    CALL apoc.ttl.expire(t, $refTokenExp, 's')
    RETURN $accTokenObj
    """)

    logout: Boolean
    @cypher(statement:"""
    OPTIONAL MATCH(u:User{id: $id})-[rel:JWT]->(oldT: Token {token: $oldTokenString})
    WITH u, oldT, EXISTS ((u)-[rel]->(oldT)) AS is_exists
    DETACH DELETE oldT
    RETURN is_exists
    """)

    refreshAccess: JSON
    @cypher(statement:"""
    MATCH(u:User{id: $id})-[rel:JWT]->(oldT: Token {token: $oldTokenString})
    WITH u, oldT
    DETACH DELETE oldT
    CREATE (u)-[rel:JWT]->(newT: Token {token: $refTokenString})
    WITH newT
    CALL apoc.ttl.expire(newT, $refTokenExp, 's')
    RETURN $accTokenObj
    """)

    CreateUser(firstName: String!, lastName: String, username: String!, email: String!, password: String!, role: Role!): User
#    @hasScope(scopes:["User:Create"])
    @cypher(statement:"""
    CREATE (u:User {
    id : apoc.create.uuid(),
    firstName : $firstName,
    lastName : $lastName,
    username : $username,
    email : $email,
    password: $password,
    avatar: $avatarHash,
    role: $role })
    RETURN u
    """)

    StartToSprint(ticket: _TicketInput!, sprintAdd: _SprintInput! ): Ticket
#    @hasScope(scopes:["Ticket:Edit", "Sprint:Edit"])
    @cypher(statement:"""
    MATCH (t:Ticket),(s:Sprint)
    WHERE t.id = $ticket.id AND s.id = $sprintAdd.id
    CREATE (t)-[rel:SPRINT_TASK]->(s)
    RETURN t
    """)

    TicToToDo(ticket: _TicketInput!, from: String!): Ticket
#    @hasScope(scopes:["Ticket:Edit"])
    @cypher(statement:"""
    CALL apoc.do.when($from = 'done',
    'MATCH (t:Ticket) WHERE t.id = $ticket.id SET t.sprintPos = 0  SET t.done = false RETURN t',
    'MATCH (t:Ticket) WHERE t.id = $ticket.id SET t.sprintPos = 0 RETURN t', {ticket: $ticket})
    YIELD value
    RETURN value.t
    """)

    TicToDoing(ticket: _TicketInput!, from: String!): Ticket
#    @hasScope(scopes:["Ticket:Edit"])
    @cypher(statement:"""
    CALL apoc.do.when($from = 'done',
    'MATCH (t:Ticket) WHERE t.id = $ticket.id SET t.sprintPos = 1  SET t.done = false RETURN t',
    'MATCH (t:Ticket) WHERE t.id = $ticket.id SET t.sprintPos = 1 RETURN t', {ticket: $ticket})
    YIELD value
    RETURN value.t
    """)

    TicToDone(ticket: _TicketInput!): Ticket
#    @hasScope(scopes:["Ticket:Edit"])
    @cypher(statement:"""
    MATCH (t:Ticket)
    WHERE t.id = $ticket.id
    SET t.sprintPos = 2
    SET t.done = true
    RETURN t
    """)

    SprintToStart(ticket: _TicketInput!, sprintRemove: _SprintInput! ): Ticket
#    @hasScope(scopes:["Ticket:Edit", "Sprint:Edit"])
    @cypher(statement:"""
    MATCH (t:Ticket {id:$ticket.id})-[rel1:SPRINT_TASK]->(s:Sprint{id:$sprintRemove.id})
    WITH t, rel1
    DELETE rel1
    RETURN t
    """)

    SwitchSprint(ticket: _TicketInput!, sprintAdd: _SprintInput!, sprintRemove: _SprintInput! ): Ticket
#    @hasScope(scopes:["Ticket:Edit", "Sprint:Edit"])
    @cypher(statement:"""
    MATCH (t:Ticket{id:$ticket.id})-[rel:SPRINT_TASK]->(s1:Sprint {id:$sprintRemove.id})
    MATCH (s2:Sprint {id:$sprintAdd.id})
    CALL apoc.refactor.to(rel, s2)
    YIELD input, output, error
    WITH t
    RETURN t
    """)

    CreateProject(title: String!, desc: String, label: String!, startDate: String!, endDate: String!, members: [_UserInput]!): Project
#    @hasScope(scopes:["Project:Create"])
    @cypher(statement:"""
    CREATE (p:Project{id: apoc.create.uuid(), title:$title,
    label:$label, startDate:$startDate, endDate:$endDate, desc:$desc })
    WITH $members AS users, p
    UNWIND users AS user
    MATCH (u:User)
    WHERE u.id = user.id
    CREATE (p)<-[:TEAM_MEMBER {role: u.role}]-(u)
    RETURN p
    """)
    AddProjectMembers(members: [_UserInput]!, project: _ProjectInput!): Project
#    @hasScope(scopes:["Project:EditMembers"])
    @cypher(statement:"""
    MATCH (p:Project)
    WHERE p.id = $project.id
    WITH $members AS users, p
    UNWIND users AS user
    MATCH (u:User)
    WHERE u.id = user.id
    CREATE (p)<-[:TEAM_MEMBER {role: u.role}]-(u)
    RETURN p
    """)
    RemoveProjectMembers(members: [_UserInput]!, project: _ProjectInput!): Project
#    @hasScope(scopes:["Project:EditMembers"])
    @cypher(statement:"""
    MATCH (p:Project)
    WHERE p.id = $project.id
    WITH $members AS users, p
    UNWIND users AS user
    MATCH (p)<-[rel:TEAM_MEMBER {role: u.role}]-(u:User)
    WHERE u.id = user.id
    DELETE rel
    RETURN p
    """)

    CreateSprint(sprintNo: Int!, active: Boolean!, startDate: String!, endDate: String!, project: _ProjectInput!): Sprint
#    @hasScope(scopes:["Sprint:Create"])
    @cypher(statement:"""
    CREATE (s:Sprint{
    id : apoc.create.uuid(),
    sprintNo: $sprintNo,
    active: $active,
    startDate: $startDate,
    endDate: $endDate
    })
    WITH s
    MATCH (p:Project) WHERE p.id = $project.id
    CREATE (s)-[r:SPRINT]->(p)
    RETURN s
    """)

    CreateTicket(hourEstimate: Int, title: String!, desc: String, project: _ProjectInput!, user: _UserInput!): Ticket
#    @hasScope(scopes:["Ticket:Create"])
    @cypher(statement:"""
    MATCH (p:Project),(u:User)
    WHERE p.id = $project.id AND u.id = $user.id
    CREATE (p)<-[:TICKET]-(t: Ticket {
    id:apoc.create.uuid(),
    title:$title,
    hourEstimate:$hourEstimate,
    sprintPos: 0,
    desc:$desc,
    done:false
    })<-[:CREATED {timestamp: datetime().epochSeconds }]-(u)
    WITH p, t
    MATCH (p)<-[r1:TICKET]-(:Ticket)
    WITH COUNT(r1) AS issNo, t
    SET t.issueNumber = issNo
    RETURN t
    """)

    CreateUserStory(storyText: String!, project: _ProjectInput!): UserStory
#    @hasScope(scopes:["UserStory:Create"])
    @cypher(statement:"""
    MATCH (p:Project)
    WHERE p.id = $project.id
    CREATE (p)<-[:USER_STORY]-(us: UserStory { id: apoc.create.uuid(), storyText: $storyText })
    WITH p, us
    MATCH (p)<-[r1:USER_STORY]-(:UserStory)
    WITH COUNT(r1) AS issNo, us
    SET us.issueNumber = issNo
    RETURN us
    """)
}
