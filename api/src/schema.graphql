    scalar JSON
    scalar idList

    enum Role {
        dev
        admin
        pm
    }

    type Token {
        token: String!
        ttl: Int!
    }

    type UserStory {
        id: ID!
        storyText: String!
        issueNumber: Int!
        tickets: [Ticket] @relation(name: "SUB_TASK", direction: IN)
        ticketIds: idList
          @cypher(statement: """
              MATCH (this)<-[:SUB_TASK]-(rec:Ticket)
              RETURN collect(rec.id) AS ids
         """)
        project: Project @relation(name: "USER_STORY", direction: OUT)
    }

    type User {
        id: ID!
        firstName: String!
        lastName: String!
        fullName: String
        username: String!
        email: String!
        password: String! @hasRole(roles:[admin])
        passwordUpdate: Boolean!
        tokens: [Token] @relation(name: "JWT", direction: OUT)
        projects: [Member]
        userStories: [UserStory] @relation(name: "ASSIGNED_TASK", direction: OUT)
        tickets: [Ticket] @relation(name: "ASSIGNED_TASK", direction: OUT)
        created: [Created]
        avatar: String
        type: Role!
    }
    type Created @relation(name: "CREATED") {
        from: User
        to: Ticket
        timestamp: String!
    }
    type Member @relation(name: "TEAM_MEMBER") {
        from: User
        to: Project
        type: Role!
    }
    type Project {
        id: ID!
        title: String!
        desc: String
        label: String!
        startDate: String!
        endDate: String!
        members: [Member]
        userStories: [UserStory] @relation(name: "USER_STORY", direction: IN)
        tickets: [Ticket] @relation(name: "TICKET", direction: IN)
        sprints: [Sprint] @relation(name: "SPRINT", direction: IN)
    }

    type Ticket {
        id: ID!
        issueNumber: Int
        hourEstimate: Int
        userStory: UserStory @relation(name: "SUB_TASK", direction: OUT)
        title: String!
        desc: String
        done: Boolean
        sprint: Sprint @relation(name: "SPRINT_TASK", direction: OUT)
        project: Project @relation(name: "TICKET", direction: OUT)
        assignee: User @relation(name: "ASSIGNED_TASK", direction: IN)
        creator: Created
    }

    type Sprint {
        id: ID!
        sprintNo: Int!
        tickets: [Ticket] @relation(name: "SPRINT_TASK", direction: IN)
        userStories: [UserStory] @cypher(statement: """
            MATCH (this)<-[:SPRINT_TASK]-(:Ticket)-[r1:SUB_TASK]->(rec:UserStory)
            WITH rec, COUNT(r1) AS num ORDER BY num DESC
            RETURN rec
         """)
        ticketIds: idList
          @cypher(statement: """
              MATCH (this)<-[:SPRINT_TASK]-(rec:Ticket)
              RETURN collect(rec.id) AS ids
         """)
        project: Project @relation(name: "SPRINT", direction: OUT)

    }

    type Query {
        ticketsAsMap: JSON
          @cypher (statement: """
           Match (n:Ticket)
           WITH n.id as key, apoc.map.removeKey(n {.*}, 'id')  as value
           RETURN apoc.map.fromPairs(collect([key, value]))
        """)

        getCurrentUser: User

    }
    type Subscription {
        update(proId:String!): String
    }
    type Mutation {
        loginUser(username: String!, password: String!): Token!
        resetPassword(username: String!, newPassword: String!): Token!
        CreateTicket(hourEstimate: Int, title: String!, desc: String, project: _ProjectInput!, user: _UserInput!): Ticket
        CreateUser(id: ID!, firstName: String!, lastName: String, username: String!, email: String!, password: String!, passwordUpdate: Boolean!): User
        UpdateTicketAssignee(tick: _TicketInput!, remUser: _UserInput, addUser: _UserInput, project: _ProjectInput!): User
        UnassignedTicketSwitch(project: _ProjectInput!, tick: _TicketInput!, uStoryRemove: _UserStoryInput, sprintRemove: _SprintInput,uStoryAdd: _UserStoryInput,sprintAdd: _SprintInput ): String
        UStoryTicketSwitch(project: _ProjectInput!, tick: _TicketInput!, uStoryRemove: _UserStoryInput, sprintRemove: _SprintInput,uStoryAdd: _UserStoryInput,sprintAdd: _SprintInput ): String
        StartToSprint(project: _ProjectInput!, tick: _TicketInput!, sprintAdd: _SprintInput! ): String
        SprintToStart(project: _ProjectInput!, tick: _TicketInput!, sprintRemove: _SprintInput! ): String
        CreateProject(
            id: ID,
            title: String!,
            desc: String,
            label: String!,
            startDate: String!,
            endDate: String!,
            members: [_UserInput]!
        ): Project
        TicSwitchSprint(tickId: String!, sprintIdFrom: String!, sprintIdTo: String!): JSON
            @cypher(statement:"""
            MATCH (a:Ticket{id:tickId})-[rel:SPRINT_TASK]->(b:Sprint {id:sprintIdFrom})
            MATCH (c:Sprint {id:sprintIdTo})
            CALL apoc.refactor.to(rel, c)
            YIELD input, output, error
            RETURN input, output, error
            """)

          TicSwitchUStory(tickId: String!, UStoryIdFrom: String!, UStoryIdTo: String!): JSON
            @cypher(statement:"""
            MATCH (a:Ticket { id:tickId })-[rel:SUB_TASK]->(b:UserStory { id:UStoryIdFrom })
            MATCH (c:UserStory { id:UStoryIdTo })
            CALL apoc.refactor.to(rel, c)
            YIELD input, output, error
            RETURN input, output, error
            """)

          TicSprintToDone(tickId: String!, sprintId: String!): JSON
            @cypher(statement:"""
            MATCH (a:Ticket{id:tickId})-[rel:SPRINT_TASK]->(b:Sprint)
            DELETE rel
            SET a.done = true
            RETURN a.id, a.done
            """)
    }
